// Generated by CoffeeScript 1.6.3
/** 
 * Copyright 2013 MacReport Media Publishing Inc.
 * Licensed under MPL-2.0 (see /LICENSE)
 * If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * 
 * Author: Sam Armstrong
*/


(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  (function(ko, window) {
    /**
     *The base class that all view models inherit from
     *Controls validations and updating of all viewModels
    */

    var AppViewModel, LazyRegister, MemberValidMethodModel, RegisteredVM, SubValidMethodModel, ValidMethodModel, ValidationModel, ViewModel;
    RegisteredVM = {};
    LazyRegister = {};
    ViewModel = (function() {
      ViewModel.Register = function(id, vm) {
        var lazyCallback, _i, _len, _ref;
        RegisteredVM[id] = vm;
        if (LazyRegister[id] != null) {
          _ref = LazyRegister[id];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            lazyCallback = _ref[_i];
            lazyCallback(RegisteredVM[id]);
          }
        }
        return void 0;
      };

      ViewModel.GetRegistered = function(id, callback) {
        if (RegisteredVM[id] != null) {
          return RegisteredVM[id];
        } else {
          if (LazyRegister[id] == null) {
            LazyRegister[id] = [];
          }
          LazyRegister[id].push(callback);
        }
        return {
          "$id": id
        };
      };

      ViewModel.ResetRegister = function() {
        return RegisteredVM = {};
      };

      ViewModel.makeInit = {
        0: function() {
          return null;
        },
        1: function() {
          return {};
        },
        2: function(key, type) {
          var classes, init, vm, vmName;
          if (type == null) {
            type = "_base";
          }
          vmName = this.model()._classes[this.model._dict(key)];
          classes = vmName;
          if ($.type(vmName) === "object") {
            classes = vmName[type];
          }
          init = this.model()[[this.model._dict(key)]];
          init["_parent"] = this.model;
          vm = new ko.ModelFactory[classes](init);
          type = type === "_base" ? vmName["_default"] : type;
          if ($.type(vmName) === "object" && (vmName[type] != null)) {
            vm['$type'] = type.split('_').join(', ');
            if (type === "_default") {
              vm['$type'] = vmName[type].split('_').join(', ');
            }
          }
          return vm;
        },
        3: function() {
          return ko.observable();
        },
        4: function(key) {
          return ko.observableArray(ViewModel.makeInit[5].call(this, key));
        },
        5: function(key) {
          this.createPushModelToArray(key);
          this.createPushNewModelToArray(key);
          this.createRemoveModelFromArray(key);
          return [];
        },
        6: function(key) {
          return ViewModel.makeInit[2].call(this, key);
        }
      };

      ViewModel.updateMethods = {
        0: function(key, data, updateVal) {
          updateVal["update"](data);
          return void 0;
        },
        1: function(key, data, updateVal, container) {
          var vm;
          vm = ViewModel.makeInit[2].call(this, key);
          vm["update"](data);
          return vm;
        },
        2: function(key, data, updateVal) {
          return data;
        }
      };

      ViewModel.findUpdateMethod = function(key, updateVal) {
        if ((updateVal != null) && (this.model()._classes[[this.model._dict(key)]] != null)) {
          return ViewModel.updateMethods[0];
        } else if ((updateVal == null) && (this.model()._classes[[this.model._dict(key)]] != null)) {
          return ViewModel.updateMethods[1];
        } else {
          return ViewModel.updateMethods[2];
        }
      };

      ViewModel.hydrate = {
        0: function(key, data) {
          return this[key] = data;
        },
        1: function(key, data) {
          var _this = this;
          if ((data != null) && (data["$ref"] != null)) {
            return ViewModel.GetRegistered(data["$ref"], function(refVM) {
              return _this[key] = refVM;
            });
          } else {
            return this[key] = data;
          }
        },
        2: function(key, data) {
          var _this = this;
          if ((data != null) && (data["$ref"] != null)) {
            return ViewModel.GetRegistered(data["$ref"], function(refVM) {
              return _this[key] = refVM;
            });
          } else {
            return this[key]["update"](data);
          }
        },
        3: function(key, data) {
          return this[key](data);
        },
        4: function(key, data) {
          var callback, index, newResults, replace, upIndex, updateMethod, val, vm, _i, _len;
          updateMethod = null;
          newResults = [];
          upIndex = 0;
          replace = this._update == null;
          if (data != null) {
            for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
              val = data[index];
              if ((this._update != null) && (this._update[key] != null)) {
                upIndex = this._update[key][index];
                replace = false;
              } else {
                upIndex = index;
              }
              updateMethod = ViewModel.findUpdateMethod.call(this, key, ko.utils.unwrapObservable(this[key])[upIndex]);
              if ((val != null) && (val['$ref'] != null)) {
                callback = ViewModel.createRefCallback(this, val['$ref'], key);
                vm = ViewModel.GetRegistered(val["$ref"], callback);
              } else {
                vm = updateMethod.call(this, key, val, ko.utils.unwrapObservable(this[key])[upIndex]);
              }
              newResults.push(vm);
            }
            if (replace) {
              this[key](this[key].slice(0, newResults.length));
              return this[key](_.flatten([newResults.slice(this[key]().length), this[key]()]));
            }
          }
        },
        5: function(key, data) {
          this[key] = ko.observableArray(this[key]);
          ViewModel.hydrate[4].call(this, key, data);
          return this[key] = this[key]();
        },
        6: function(key, data) {
          var dictKey, dictVal, obj, val, _i, _len;
          obj = {};
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            val = data[_i];
            obj[val.Key] = val.Value;
          }
          for (dictKey in obj) {
            dictVal = obj[dictKey];
            if (this[key][dictKey] == null) {
              this[key][dictKey] = ViewModel.makeInit[this[key].model()["_jsTypes"][this[key].model._dict(dictKey)]].call(this, "Value");
            }
          }
          return this[key].update(obj);
        }
      };

      ViewModel.createRefCallback = function(vm, id, key) {
        var _this;
        _this = vm;
        return function(refVM) {
          var arr, refid;
          arr = ko.utils.unwrapObservable(_this[key]);
          refid = _(arr).pairs().first(function(pair) {
            return pair[1]['$id'] === id;
          });
          return ko.utils.unwrapObservable(_this[key])[refid.value()[0][0]] = refVM;
        };
      };

      ViewModel.validateStepMessages = {
        0: function(key, step) {
          return [];
        },
        1: function(key, step) {
          return [];
        },
        2: function(key, step) {
          return this[key].getValidateMessages(step);
        },
        3: function(key, step) {
          if ((this.validationModels != null) && (this.validationModels[key] != null)) {
            return _(this.validationModels[key].validations).values().filter(function(x) {
              return x.step === step || step === null;
            }).value();
          } else {
            return [];
          }
        },
        4: function(key, step) {
          var messages, val, _i, _len, _ref;
          messages = [];
          if (this.model()["_classes"][key] != null) {
            _ref = ko.utils.unwrapObservable(this[key]);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              val = _ref[_i];
              messages.push(val.getValidateMessages(step));
            }
          }
          messages.push(ViewModel.validateStepMessages[3].call(this, key, step));
          return messages;
        },
        5: function(key, step) {
          return ViewModel.validateStepMessages[4].call(this, key, step);
        },
        6: function(key, step) {
          return [];
        }
      };

      ViewModel.validationObject = {
        0: function(model, first, step, key) {
          return true;
        },
        1: function(model, first, step, key) {
          return true;
        },
        2: function(model, first, step, key) {
          return this[key].createValidationObject(model[key], false, step);
        },
        3: function(model, first, step, key) {
          if ((this.validationModels != null) && this.validationModels.hasOwnProperty(key) && this.validationModels[key].messages().indexOf("") > -1) {
            return false;
          }
          return true;
        },
        4: function(model, first, step, key) {
          return this.createValidationArrayObject(this[key], model[key], first, step, key);
        },
        5: function(model, first, step, key) {
          return ViewModel.validationObject[4].call(this, model, first, step, key);
        },
        6: function(model, first, step, key) {
          return true;
        }
      };

      /**
       * Returns an object representation of the viewModel with everything stripped out except the properties that need validation
       * to return to the server for validation
       * @param {object} model :a copy of the initial object that is being stripped of all unnecessary values
       * @param {bool} first   :a bool to signify if the function, which is being called recursively, is back to the top of the stack
       *                        so that it can return the final copy of the function or an indication of if the object has no subvalidations
       *                        and can therefore be deleted
       * @return {object}
      */


      ViewModel.prototype.createValidationObject = function(model, first, step) {
        var deleteProperty, deleteThis, key;
        if (model == null) {
          model = $.parseJSON(this.initialCopy());
        }
        if (first == null) {
          first = true;
        }
        if (step == null) {
          step = null;
        }
        deleteThis = true;
        for (key in this.model()["_jsTypes"]) {
          deleteProperty = ViewModel.validationObject[this.model()["_jsTypes"][key]].call(this, model, first, step, key);
          if (deleteProperty) {
            delete model[key];
          } else {
            deleteThis = false;
          }
        }
        if (first) {
          return model;
        } else {
          return deleteThis;
        }
      };

      /**
       * Returns and array of objects which have been stripped by the createValidationObject
       * @param  {Array<object>} modelArray       :the array of models being checked to see if it's properties need validation
       * @param  {Array<object>} validObjectArray :the copied array with only the values that need to be validated
       * @return {Array<object>}
      */


      ViewModel.prototype.createValidationArrayObject = function(modelArray, validObjectArray, first, step, key) {
        var deleteIndex, deleteThis, deletions, index, val, _i, _len, _ref;
        deleteThis = true;
        deletions = 0;
        _ref = ko.utils.unwrapObservable(modelArray);
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          val = _ref[index];
          deleteIndex = true;
          if ($.isArray(ko.utils.unwrapObservable(val))) {
            deleteIndex = this.createValidationArrayObject(validObjectArray[index - deletions], val, first, step, key);
          } else if (this.model()["_classes"][key] != null) {
            deleteIndex = val.createValidationObject(validObjectArray[index - deletions], false, step);
          }
          if (deleteIndex) {
            validObjectArray.remove(validObjectArray[index - deletions]);
            deletions++;
          } else {
            deleteThis = false;
          }
        }
        return deleteThis;
      };

      /**
       * Takes the initial structure of a view model and creates the corresponding viewmodel
       * @param  {object} initial             :initial structure of the viewmodel
      */


      function ViewModel(initial, data) {
        this.scrubbedCopy = __bind(this.scrubbedCopy, this);
        this.copy = __bind(this.copy, this);
        /*
        Create Stub Object and accessors (private variables)
        */

        var index, key, model, val, _ref;
        if ((initial != null) && (initial["this"] == null)) {
          model = initial;
          index = initial['$ref'] != null ? model['$ref'] : -1;
          while (index > 0) {
            index--;
            model = model['_parent'];
          }
          if (index !== -1) {
            model = model();
          }
          model = ko.toJSON(model);
          this.model = function() {
            return $.parseJSON(model);
          };
          this.model["_parent"] = initial["_parent"];
          delete initial["_parent"];
          this.modelEmptyArrs = function() {
            var emptyArrsModel, key, val;
            emptyArrsModel = this.model();
            for (key in emptyArrsModel) {
              val = emptyArrsModel[key];
              if ($.isArray(ko.utils.unwrapObservable(val))) {
                val.pop();
              }
            }
            return emptyArrsModel;
          };
          this.arrayModelEmptyArrs = function(key) {
            var emptyArrsModel, val;
            emptyArrsModel = this.arrayModels(key);
            for (key in emptyArrsModel) {
              val = emptyArrsModel[key];
              if ($.isArray(ko.utils.unwrapObservable(val))) {
                val.pop();
              }
            }
            return emptyArrsModel;
          };
          this.model._dict = function(key) {
            return key;
          };
          if (this.model().postUrl != null) {
            this.postUrl = this.model().postUrl;
          }
          _ref = this.model()['_jsTypes'];
          for (key in _ref) {
            val = _ref[key];
            this[key] = ViewModel.makeInit[val].call(this, key);
          }
          if (data != null) {
            this.update(data);
          }
          if (this.model()['_validations'] != null) {
            this.createValidations(this.model()['_validations']);
          }
        } else if (initial["this"] != null) {
          model = ko.toJSON(initial["this"]);
          this.model = function() {
            return $.parseJSON(model);
          };
          this.model["parent"] = initial["$parent"];
          delete initial["$parent"];
          this.model._dict = function(key) {
            return "Value";
          };
          if (data != null) {
            this.update(data);
          }
        }
      }

      /**
       * Updates all properties inside of "this"
       * @param  {object} initial :a object with the shape of "this" viewmodel, which modifys the values inside correctly
       * @return {ViewModel}
      */


      ViewModel.prototype.update = function(initial) {
        var key, val;
        for (key in initial) {
          val = initial[key];
          if (key === '$id') {
            ViewModel.Register(val, this);
          } else {
            ViewModel.hydrate[this["model"]()["_jsTypes"][this.model._dict(key)]].call(this, key, val);
          }
        }
        if (this.hydrateBackup != null) {
          this.hydrateBackup();
          delete this.hydrateBackup;
        }
        return this;
      };

      /**
       * Takes the initial structure of validations inside the viewmodel, and maps them to the existing 
        members in the model
       * @param  {validationObject} validations :an object with validation names and structures inside
       * @return {ViewModel}
      */


      ViewModel.prototype.createValidations = function(validations) {
        var key, val, validationMessages, _ref;
        if (this.validationModels == null) {
          this.validationModels = {};
        }
        for (key in validations) {
          val = validations[key];
          this.validationModels[key] = new ko.ModelFactory.ValidationModel(this, key, val);
        }
        validationMessages = ko.observableArray();
        _ref = this.validationModels;
        for (key in _ref) {
          val = _ref[key];
          validationMessages.push(val.messages);
        }
        this.isModelValid = this.createValidationObservable(validationMessages);
        return this;
      };

      /**
       * Gets a validation object recursively to send to server
       * @return {Array<observable>}
      */


      ViewModel.prototype.getTopModelValidation = function() {
        var arrVal, isValidArray, key, val, _i, _len, _ref;
        isValidArray = [];
        for (key in this) {
          val = this[key];
          if (ko.utils.unwrapObservable(val) instanceof ViewModel) {
            ko.utils.arrayPushAll(isValidArray, ko.utils.unwrapObservable(val.getTopModelValidation()));
          }
          if ($.isArray(ko.utils.unwrapObservable(val))) {
            _ref = ko.utils.unwrapObservable(val);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              arrVal = _ref[_i];
              ko.utils.arrayPushAll(isValidArray, ko.utils.unwrapObservable(arrVal.getTopModelValidation()));
            }
          }
        }
        if (this.isModelValid != null) {
          isValidArray.push(this.isModelValid);
        }
        return isValidArray;
      };

      /**
       * Creates a computed observable that returns a bool of if the specific messages being watched have messages.
       * if no messages, the model is validated and correct
       * @param  {Array<computed>} messageArray :an array of computed observables which return an array of messages
       * @return {computed}
      */


      ViewModel.prototype.createValidationObservable = function(step) {
        var isValid, messageArray;
        if (step == null) {
          step = null;
        }
        messageArray = ko.observableArray(_.map(this.getValidateMessages(step), function(validation) {
          return validation.message;
        }));
        isValid = ko.computed({
          read: function() {
            var message, _i, _len, _ref;
            _ref = ko.utils.unwrapObservable(messageArray);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              message = _ref[_i];
              if (message() !== "Valid") {
                return false;
              }
            }
            return true;
          }
        }).extend({
          throttle: 500
        });
        setTimeout((function() {
          return isValid.notifySubscribers(isValid.peek());
        }), 1000);
        return isValid;
      };

      /**
       * Creates a computed observable that returns a bool of if the messages passed into the function are blank, signifying that
       * their validity is uncertain and need to be validated
       * @param  {Array<computed>} messageArray :an array of computed observables which return an array of messages
       * @return {computed}
      */


      ViewModel.prototype.createShouldValidateObservable = function(step) {
        var messageArray, shouldValidate;
        if (step == null) {
          step = null;
        }
        messageArray = ko.observableArray(_.map(this.getValidateMessages(step), function(validation) {
          return validation.message;
        }));
        shouldValidate = ko.computed({
          read: function() {
            var val, _i, _len, _ref;
            _ref = ko.utils.unwrapObservable(messageArray);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              val = _ref[_i];
              if (val() === "") {
                return true;
              }
            }
            return false;
          }
        }).extend({
          throttle: 500
        });
        setTimeout((function() {
          return shouldValidate.notifySubscribers(shouldValidate.peek());
        }), 1000);
        return shouldValidate;
      };

      ViewModel.prototype.getValidateMessages = function(step) {
        var _this = this;
        if (step == null) {
          step = null;
        }
        return _(this.model()["_jsTypes"]).keys().map(function(key) {
          return ViewModel.validateStepMessages[_this.model()["_jsTypes"][key]].call(_this, key, step);
        }).flatten().value();
      };

      /**
       * Takes the validations from the server and puts them in the correct position in the object
       * @param  {object} initial :a validation object with the shape of "this" viewModel
       * @return {ViewModel}
      */


      ViewModel.prototype.updateValidation = function(initial) {
        var key, val, validKey, validVal, _ref;
        for (key in initial) {
          val = initial[key];
          if ($.isArray(ko.utils.unwrapObservable(this[key]))) {
            this.updateValidationArray(key, val);
          } else if (key === "validationModels") {
            _ref = initial[key];
            for (validKey in _ref) {
              validVal = _ref[validKey];
              this[key][validKey].update(validVal);
            }
          } else {
            this[key].updateValidation(val);
          }
        }
        return this;
      };

      /**
       * Takes the validation array from the server and puts them in the correct position in the array
       * @param  {string} key     :key for the array inside of the object
       * @param  {Array<object>} initial :validation array
       * @return {ViewModel}
      */


      ViewModel.prototype.updateValidationArray = function(key, initial) {
        var index, notUpdated, val, _i, _len, _ref;
        notUpdated = 0;
        _ref = ko.utils.unwrapObservable(this[key]);
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          val = _ref[index];
          if (val.checkUpdateValidation(initial[index - notUpdated])) {
            val.updateValidation(initial[index - notUpdated]);
          } else {
            notUpdated -= 1;
          }
        }
        return this;
      };

      /**
       * Checks if the object needs to be updated with the object that is being passed
       * @param  {object} initial :validation object with new validations
       * @return {bool}
      */


      ViewModel.prototype.checkUpdateValidation = function(initial) {
        var key, val, validKey, validVal, _ref;
        for (key in initial) {
          val = initial[key];
          if ($.isArray(ko.utils.unwrapObservable(this[key]))) {
            if (this.checkArrayUpdateValidation(key, val)) {
              return true;
            }
          } else if (key === "validationModels") {
            _ref = initial[key];
            for (validKey in _ref) {
              validVal = _ref[validKey];
              if (this[key][validKey].checkUpdateValidation(validVal)) {
                return true;
              }
            }
          } else {
            if (this[key].checkUpdateValidation(val)) {
              return true;
            }
          }
        }
        return false;
      };

      /**
       * An array version of checkUpdateValidation
       * @param  {string} key     :keey fo rthe array inside the object
       * @param  {Array<object>} initial :initial array of validation objects with new validations
       * @return {bool}
      */


      ViewModel.prototype.checkArrayUpdateValidation = function(key, initial) {
        var index, update, val, _i, _len, _ref;
        update = false;
        _ref = ko.utils.unwrapObservable(this[key]);
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          val = _ref[index];
          if (val.checkUpdateValidation(initial[index - notUpdated])) {
            return true;
          } else {
            notUpdated -= 1;
          }
        }
        return false;
      };

      /**
       * Creates a push new function for arrays of ViewModels, which adds and empty instance, with the shape of the ViewModels already in the array
       * @param  {string} key :key for the array property inside of "this"
       * @return {function}
      */


      ViewModel.prototype.createPushNewModelToArray = function(key) {
        var updateMethod,
          _this = this;
        updateMethod = ViewModel.findUpdateMethod.call(this, key, null);
        return this["pushNew" + key] = function() {
          var newModel;
          newModel = updateMethod.call(_this, key);
          if (_this["processNewViewModel"]) {
            _this["processNewViewModel"](newModel);
          }
          if ((_this["processNew" + key] != null)) {
            _this["processNew" + key](newModel);
          }
          return _this[key].push(newModel);
        };
      };

      /**
       * Creates a push function for arrays of the ViewModel, which adds an existing instance of the ViewModels already in the arrays
       * @param  {string} key :key for the array property inside of "this"
       * @return {function}
      */


      ViewModel.prototype.createPushModelToArray = function(key) {
        var updateMethod,
          _this = this;
        updateMethod = ViewModel.findUpdateMethod.call(this, key, null);
        return this["push" + key] = function(model) {
          var newModel;
          newModel = updateMethod.call(_this, key, _this.recursiveCopyObj(ko.toJS(model), _this.model()[key]));
          if (_this["processViewModel"]) {
            _this["processViewModel"](newModel);
          }
          if ((_this["process" + key] != null)) {
            _this["process" + key](newModel);
          }
          return _this[key].push(newModel);
        };
      };

      /**
       * Creates a remove function for arrays of the ViewModel, which removes an existing instance of the ViewModels already in the arrays
       * @param  {string} key :key for the array property inside of "this"
       * @return {function}
      */


      ViewModel.prototype.createRemoveModelFromArray = function(key) {
        var _this = this;
        return this["remove" + key] = function(item) {
          if ((_this["processRemoveViewModel"] != null)) {
            _this["processRemoveViewModel"](item);
          }
          return _this[key].remove(item);
        };
      };

      /**
       * Creates a clean copy of this ViewModel using the correct prototype
       * @return {ViewModel}
      */


      ViewModel.prototype.copy = function() {
        var key, obj;
        obj = this.recursiveCopyObj(ko.toJS(this), this.model());
        key = this.constructor.name;
        return new ko.ModelFactory[key](this.model(), obj);
      };

      /**
       * Creates a Json copy of the object with only the initial properties from it's creation
       * @param  {function} arg :a function to be applied to the ViewModel before it is transformed into a json string
       * @return {string}
      */


      ViewModel.prototype.initialCopy = function(processInitial) {
        var initial;
        if (processInitial == null) {
          processInitial = function(arg) {
            return arg;
          };
        }
        initial = this.model();
        return ko.toJSON(this.recursiveCopyObj(ko.toJS(this), initial, [], processInitial));
      };

      /**
       * creates a model which has nulled out values of only the initial properties from it's creation
       * @return {ViewModel}
      */


      ViewModel.prototype.scrubbedCopy = function() {
        var initial, key;
        initial = this.model();
        key = this.constructor.name;
        return new ko.ModelFactory[key](initial);
      };

      /**
       * Recursively copies values into another object where the objects have the same keys
       * @param  {object} :copyObj :the object that is being copied
       * @param  {object} :initial :the object being copied into
       * @return {[type]}
      */


      ViewModel.prototype.recursiveCopyObj = function(copyObj, initial, keys, processInitial) {
        var arrVal, cleanCopyObj, index, key, obj, val, _i, _len, _ref, _ref1;
        if (keys == null) {
          keys = [];
        }
        if (processInitial == null) {
          processInitial = function(args) {
            return args;
          };
        }
        obj = {};
        cleanCopyObj = ko.utils.unwrapObservable(copyObj);
        _ref = initial["_jsTypes"];
        for (key in _ref) {
          val = _ref[key];
          keys.push(key);
          if (cleanCopyObj.hasOwnProperty(key)) {
            if (val === 4 || val === 6) {
              obj[key] = [];
              _ref1 = processInitial(cleanCopyObj[key], keys);
              for (index = _i = 0, _len = _ref1.length; _i < _len; index = ++_i) {
                arrVal = _ref1[index];
                obj[key].push(this.recursiveCopyObj(arrVal, initial[key], keys, processInitial));
              }
            } else if (val === 1 || val === 2) {
              obj[key] = this.recursiveCopyObj(cleanCopyObj[key], initial[key], keys, processInitial);
            } else {
              if (cleanCopyObj[key] === void 0) {
                cleanCopyObj[key] = null;
              }
              obj[key] = ko.utils.unwrapObservable(processInitial(cleanCopyObj[key], keys));
            }
          } else {
            obj[key] = null;
          }
          keys.pop();
        }
        return obj;
      };

      /**
       * Creates functions which save the state of an object, and to which the object can be restored
       * @return {[type]}
      */


      ViewModel.prototype.createBackup = function() {
        var dataBackup, key,
          _this = this;
        dataBackup = ko.observable(this.initialCopy());
        this.getBackup = function() {
          return dataBackup();
        };
        this.updateBackup = function() {
          dataBackup(_this.initialCopy());
          return _this.needsUpdate(false);
        };
        this.needsUpdate = ko.observable(false);
        for (key in ko.utils.parseJson(dataBackup())) {
          if (ko.isObservable(this[key])) {
            this[key].subscribe(function() {
              return _this.needsUpdate(dataBackup() !== _this.initialCopy());
            });
          }
        }
        dataBackup.subscribe(function(newValue) {
          return _this.needsUpdate(newValue !== _this.initialCopy());
        });
        this.restoreBackup = function() {
          return _this.update(ko.utils.parseJson(_this.getBackup()));
        };
        return this.hydrateBackup = _.once(function() {
          return _this.updateBackup();
        });
      };

      return ViewModel;

    })();
    /**
     * The Validation model which controls how models are validated
    */

    ValidationModel = (function() {
      /**
       * ValidationModel Constructor
       * @param  {ViewModel} parent       :This is the ViewModel that the Validation Model belongs to
       * @param  {observable} key         :This is the key of the property inside of the ViewModel which is being watched for validations
       * @param  {object} validObjects    :This contains the names of the validations which need to be created
       * @return {ValidationModel}
      */

      function ValidationModel(parent, key, validObjects) {
        this.validations = {};
        this.addValidations(parent, key, validObjects);
        this;
      }

      /**
       * Goes throught each Validation and updates the message they've recieved from their validation
       * @param  {object} initial :contains the validation messages from the server
       * @return {ValidationModel}
      */


      ValidationModel.prototype.update = function(initial) {
        var key, val;
        for (key in initial) {
          val = initial[key];
          this.validations[key].update(val);
        }
        return this;
      };

      /**
       * Returns if any of the validation messages are blank
       * @return {bool}
      */


      ValidationModel.prototype.checkUpdateValidation = function() {
        if (this.messages().indexOf("") > -1) {
          return true;
        }
        return false;
      };

      /**
       * Creates a computed observable that looks at all the messages and only returns those thare aren't valid
       * @param  {ViewModel} parent :The parent observable which must be checked to if the validation message should be shown
       * @return {ValidationModel}
      */


      ValidationModel.prototype.createComputed = function(parent) {
        var _this = this;
        this.messages = ko.computed(function() {
          var key, messageArray, parentVal, undef, val, _ref;
          messageArray = [];
          undef = false;
          if (typeof parent !== "undefined") {
            undef = true;
            parentVal = ko.utils.unwrapObservable(parent);
          }
          _ref = _this.validations;
          for (key in _ref) {
            val = _ref[key];
            if ((undef || !(!_this.validations.hasOwnProperty("NotNull") && (parentVal === null || parentVal === ""))) && val.message() !== "Valid") {
              messageArray.push(val.message());
            }
          }
          return messageArray;
        }).extend({
          throttle: 50
        });
        return this;
      };

      /**
       * Adds a validation if it doesn't already exist
       * @param {ViewModel} parent       :parent ViewModel which is checked first to see if the property to be observed even exists
       * @param {string} key             :key of the property in the paren that needs to be observed
       * @param {object} validObjects    :contains each validation that needs to be run on the property inside the parent
      */


      ValidationModel.prototype.addValidations = function(parent, key, validObjects) {
        var flag, val, validKey;
        flag = false;
        for (validKey in validObjects) {
          val = validObjects[validKey];
          if (this.validations[key] == null) {
            flag = true;
            if ((parent[key] != null) && (this.validations[validKey] == null)) {
              this.validations[validKey] = new ko.ModelFactory.MemberValidMethodModel(parent[key], val.step);
            } else if (key === "this") {
              if (this.validations[validKey] != null) {
                this.validations[validKey].setupSubValidations(parent, validKey, val);
              } else {
                this.validations[validKey] = new ko.ModelFactory.SubValidMethodModel(parent, validKey, val);
              }
            }
          }
        }
        if (flag) {
          this.createComputed(parent[key]);
        }
        return this;
      };

      return ValidationModel;

    })();
    /**
     * Base class for each validation method that needs to be run on the server
    */

    ValidMethodModel = (function() {
      function ValidMethodModel() {
        this.message = ko.observable("");
      }

      ValidMethodModel.prototype.update = function(initial) {
        return this.message(initial.message);
      };

      return ValidMethodModel;

    })();
    /**
     * A ValidationMethodModel which ensures all objects required for the validation are returned to the server for validation
     * Creates MemberValidMethodModels underneath other properties. Key should always be a specific property inside the ViewModel
     * but always represent the viewModel itself. Is not capable of mapping validations using properties in ViewModels that are part of Arrays
    */

    SubValidMethodModel = (function(_super) {
      __extends(SubValidMethodModel, _super);

      function SubValidMethodModel(parent, validKey, validArgs) {
        SubValidMethodModel.__super__.constructor.call(this);
        this.setupSubValidations(parent, validKey, validArgs);
      }

      /**
       * Creates the MemberValidationMethods inside of other properties, and creates subscriptions to notify those models of returned messages
       * @param  {ViewModel} parent        :the parent ViewModel which has the values needed to check the validation
       * @param  {string} validKey         :the key to store the ValidationModel under inside of the parent's ValidationModels object (normally "this")
       * @param  {Array<String>} validArgs :the paths to the properties which are required for validation
       * @return {SubValidMethodModel}
      */


      SubValidMethodModel.prototype.setupSubValidations = function(parent, validKey, validObj) {
        var args, key, parentIttr, passedMessage, path, pathIttr, validArgs, x, _i, _j, _len, _len1, _ref,
          _this = this;
        passedMessage = this.message;
        this.step = validObj.step;
        validArgs = validObj.args;
        for (_i = 0, _len = validArgs.length; _i < _len; _i++) {
          args = validArgs[_i];
          pathIttr = parent;
          /**
           * traverse through the parent viewModel until you get the the argument that needs to be watched
          */

          _ref = args.split(".");
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            path = _ref[_j];
            parentIttr = pathIttr;
            pathIttr = pathIttr[path];
            key = path;
          }
          /**
           *Ensure that the key exists and create a stub ValidationModel, or add a new ValidationMethod to the existing Validation Model
          */

          if (parentIttr[key] != null) {
            x = {};
            x[key] = {};
            x[key][validKey] = {
              "step": validObj.step,
              "args": []
            };
            if (parentIttr.validationModels == null) {
              parentIttr.validationModels = {};
            }
            if (parentIttr.validationModels[key] == null) {
              parentIttr.validationModels[key] = new ko.ModelFactory.ValidationModel(parentIttr, key, x[key]);
            } else {
              parentIttr.validationModels[key].addValidations(parentIttr, key, x[key]);
            }
            /**
             * Subscribe the observable parameter to monitor for changes
            */

            if (ko.isObservable(parentIttr[key])) {
              parentIttr[key].subscribe(function(newValue) {
                return passedMessage("");
              });
            }
            /**
             * Remove the subscription previously created when we created the new ValidationMethodModel
            */

            parentIttr.validationModels[key].validations[validKey].subscription.dispose();
            /**
             * create a messages property incase other subValidationModels need to use this argument
             * and then push this validation's message observable into that array
            */

            if (typeof parentIttr.validationModels[key].validations[validKey].messages === 'undefined') {
              parentIttr.validationModels[key].validations[validKey].messages = [];
            }
            parentIttr.validationModels[key].validations[validKey].messages.push(passedMessage);
            /**
             * replace the old validation message with a new one which signifies the state of any owning subValidationMethods being invalid
             * and therefore this model will be sent back to the server if any of those validationMethods need it
            */

            parentIttr.validationModels[key].validations[validKey].message = this.createComputed(parentIttr.validationModels[key].validations[validKey].messages);
            parentIttr.validationModels[key].createComputed();
          }
        }
        return this;
      };

      /**
       * Create a computed that returns if any of the messages in the message array are not valid
       * @param  {Array<observable>} messageArray :an array of observable messages from parent subValidationMethods
       * @return {[type]}
      */


      SubValidMethodModel.prototype.createComputed = function(messageArray) {
        return ko.computed({
          read: function() {
            var message, _i, _len;
            for (_i = 0, _len = messageArray.length; _i < _len; _i++) {
              message = messageArray[_i];
              if (message() !== "Valid") {
                return message();
              }
            }
            return "Valid";
          },
          write: function(value) {
            var message, _i, _len, _results;
            _results = [];
            for (_i = 0, _len = messageArray.length; _i < _len; _i++) {
              message = messageArray[_i];
              _results.push(message(value));
            }
            return _results;
          }
        }).extend({
          throttle: 50
        });
      };

      return SubValidMethodModel;

    })(ValidMethodModel);
    MemberValidMethodModel = (function(_super) {
      __extends(MemberValidMethodModel, _super);

      function MemberValidMethodModel(subscriptionObservable, step) {
        var _this = this;
        MemberValidMethodModel.__super__.constructor.call(this);
        this.step = step;
        this.subscription = {};
        if (ko.isObservable(subscriptionObservable)) {
          this.subscription = subscriptionObservable.subscribe(function(newValue) {
            return _this.message("");
          });
        }
      }

      return MemberValidMethodModel;

    })(ValidMethodModel);
    AppViewModel = (function(_super) {
      __extends(AppViewModel, _super);

      AppViewModel.make = {
        Object: function(key, data) {
          return new ko.ModelFactory[this._stubs["_classes"][key]](this._stubs[key], data);
        },
        IDictionary: function(key, data) {
          var obj, val, _i, _len;
          obj = {};
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            val = data[_i];
            obj[val['Key']] = val['Value'];
          }
          return new ko.ModelFactory[this._stubs["_classes"][key]](this._stubs[key], obj);
        },
        IList: function(key, data) {
          var val, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            val = data[_i];
            _results.push(new ko.ModelFactory[this._stubs["_classes"][key]](this._stubs[key], val));
          }
          return _results;
        }
      };

      function AppViewModel(initial, data) {
        if (initial.postUrl != null) {
          this.postUrl = initial.postUrl;
          delete initial.postUrl;
        }
        this.insertViewModels(initial);
      }

      AppViewModel.prototype.insertViewModels = function(viewModels) {
        var key, val, _i, _j, _len, _len1, _ref, _ref1;
        if (this._stubs != null) {
          _ref = viewModels._stubs;
          for (val = _i = 0, _len = _ref.length; _i < _len; val = ++_i) {
            key = _ref[val];
            this._stubs[key] = val;
          }
          _ref1 = viewModels._vmType;
          for (val = _j = 0, _len1 = _ref1.length; _j < _len1; val = ++_j) {
            key = _ref1[val];
            this._vmType[key] = val;
          }
        } else {
          this._stubs = viewModels._stubs;
          this._vmType = viewModels._vmType;
        }
        delete viewModels._stubs;
        delete viewModels._vmType;
        for (key in viewModels) {
          val = viewModels[key];
          if (this._stubs[key] != null) {
            this[key] = AppViewModel.make[this._vmType[key]].call(this, key, val);
          } else {
            this[key] = new ko.ModelFactory["AppViewModel"](val);
          }
        }
        return this;
      };

      return AppViewModel;

    })(ViewModel);
    ko.ModelFactory = {};
    ko.ModelFactory.ViewModel = ViewModel;
    ko.ModelFactory.AppViewModel = AppViewModel;
    ko.ModelFactory.MemberValidMethodModel = MemberValidMethodModel;
    ko.ModelFactory.ValidMethodModel = ValidMethodModel;
    ko.ModelFactory.SubValidMethodModel = SubValidMethodModel;
    return ko.ModelFactory.ValidationModel = ValidationModel;
  })(ko, this);

  Array.prototype.remove = function(e) {
    var t, _ref;
    if ((t = this.indexOf(e)) > -1) {
      return ([].splice.apply(this, [t, t - t + 1].concat(_ref = [])), _ref);
    }
  };

}).call(this);

/*
//@ sourceMappingURL=ViewModel.map
*/
